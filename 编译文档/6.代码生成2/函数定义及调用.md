#### 函数定义及调用

＜参数表＞

＜声明头部＞

＜有返回值函数定义＞

＜无返回值函数定义＞

与表达式有关



#### 数组声明和使用

变量定义

与表达式有关



#### 各种语句

* ＜条件语句＞
  * ＜条件＞
* ＜循环语句＞
  * ＜步长＞
* ＜情况语句＞
  * ＜情况表＞
  * ＜情况子语句＞
  * ＜缺省＞

（这里没有把函数有关的东西加进去）





#### 需要做的操作

局部变量清零

寄存器优化





先从函数开始写把：





关于数组：

数组需要空间

数组需要get x=a[]

数组需要put a[]=，

涉及到：

变量定义无初始化

变量定义及初始化

因子-项-表达式

赋值语句



二维数组也是一维数组



形式：

arrayget	dst= arrayName arrayIndex 

arrayput  arrayName arrayIndex =dst









首先判断数组下标是不是常数

如果是常数：

把首地址装入a0,然后加上偏移

再进行操作



如果不是常数：



第一：

arrayput就是

数组在全局变量中，直接通过名字存取:

lw \$t0,label(\$t1)

sw \$t0,label(\$t1)

数组在局部变量中：

先根据数组名字取出偏移

然后加上偏移得到地址

然后进行操作



getarray

就是从array里面取值





函数需要保存

用fp指针来保存所有参数，这里的参数包括 值参数表和函数里面定义的变量



sp是栈，用sp来保存局部变量





跳转到一个函数：

减少sp

保存ra

保存参数

保存局部变量

更新局部变量表





跳转回去前：

（局部变量不用管了）

设置返回参数

增加sp

jr ra





如果需要递归：

把ra 取出来

把局部变量取出来

增加sp

设置参数（可能）

jr ra





涉及到四种语句：

label

push

call

ret

还要涉及到的东西：

符号表的替换





push时：

把所有值按照偏移存到fp中，也就是说fp中保存所有的参数

偏移offset好像是只跟push和call有关，每push一个offset-4，也就是说参数时放在fp下面的



call begin时

sp=fp，这里意味着参数表的替换，因为局部变量是跟sp有关的，所以这里局部变量的其实直接变成了fp,fp的开头是参数

jal



call end时

fp=sp，这里是什么操作，这里我还要再看一下

sp=sp-func_offset(函数的偏移其实就是函数所有变量的总大小)，



ret

如果有参数就把参数装进v0

如果函数是不是叶子函数，就说明保存了ra,需要把ra从sp中取出来

jr ra





label:

替换局部变量表

把ra存进sp

fp=sp+func_offset(也就是函数所有参数的大小)









整个过程是：

push

fp中存入参数，此时fp大小不变，但是fp下面装入了所有的参数



call begin

sp=fp 这里意味着参数表的替换，因为局部变量是跟sp有关的，所以这里局部变量的其实直接变成了fp,fp的开头是参数

jal



label

替换局部变量表

把ra存进sp,0的位置，因为我们在存数据的时候总是从sp-4开始存的，所以这里sp0的位置刚好可以存ra

fp=sp+func_offset(也就是函数所有参数的大小)

​	由于call的存在，sp==fp，实际上是操作fp=fp+func_offset，也就是让fp偏移了函数的所有参数大小（这里fp应该是向下的，因为offset<0)



ret

如果有参数就把参数装进v0

如果函数不是叶子函数，就说明ra变化过，需要把ra从sp中取出来

jr ra



call end

fp=sp，这里的sp是最开始的fp，也就是Push和call begin时的fp，也就是fp=fp+func_offset之前的那个fp，让fp变回去，其实就是指之前分配的那些fp空间已经不需要了，

sp=sp-func_offset，让sp变回去，sp=之前的那个fp-func_offset(这里用-号说明sp是往上涨的) 也就是sp在fp的上面



